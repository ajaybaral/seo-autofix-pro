<?php
/**
 * Link Analyzer - Applies fixes to broken links
 * 
 * @package SEOAutoFix\BrokenUrlManagement
 */

namespace SEOAutoFix\BrokenUrlManagement;

// Exit if accessed directly
if (!defined('ABSPATH')) {
    exit;
}

/**
 * Link Analyzer Class
 */
class Link_Analyzer
{

    /**
     * Database manager
     */
    private $db_manager;

    /**
     * Universal replacement engine (builder-agnostic)
     */
    private $universal_engine;

    /**
     * Header/Footer replacer (site-wide elements)
     */
    private $header_footer_replacer;

    /**
     * Constructor
     */
    public function __construct()
    {
        $this->db_manager = new Database_Manager();
        $this->universal_engine = new Universal_Replacement_Engine();
        $this->header_footer_replacer = new Header_Footer_Replacer();
    }

    /**
     * Apply fixes for selected broken links
     * 
     * @param array $entry_ids Entry IDs to fix
     * @param string $custom_url Optional custom URL to use for replacement
     * @return array Result with counts
     */
    public function apply_fixes($entry_ids, $custom_url = '')
    {
        \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Starting with entry IDs: ' . print_r($entry_ids, true));
        \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Custom URL provided: ' . $custom_url);

        $fixed_count = 0;
        $failed_count = 0;
        $skipped_count = 0;
        $messages = array();

        foreach ($entry_ids as $entry_id) {
            \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Processing entry ID: ' . $entry_id);

            // Get entry details
            $entry = $this->db_manager->get_entry($entry_id);

            if (!$entry) {
                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Entry not found: ' . $entry_id);
                $failed_count++;
                $messages[] = sprintf(
                    __('Entry #%d not found', 'seo-autofix-pro'),
                    $entry_id
                );
                continue;
            }

            \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Entry data: ' . print_r($entry, true));

            // Check if this is a template-generated link that can't be fixed
            if ($this->is_template_generated_link($entry['broken_url'])) {
                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Skipping template-generated link: ' . $entry['broken_url']);
                $skipped_count++;
                $messages[] = sprintf(
                    __('⚠️ Cannot fix: %s - This link is generated by WordPress theme/templates. Please fix it in your theme files or comment settings.', 'seo-autofix-pro'),
                    esc_url($entry['broken_url'])
                );
                continue;
            }

            // Determine replacement URL priority: custom_url > user_modified_url > suggested_url
            $replacement_url = '';

            if (!empty($custom_url)) {
                $replacement_url = $custom_url;
                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Using custom URL from parameter: ' . $replacement_url);
            } elseif (!empty($entry['user_modified_url'])) {
                $replacement_url = $entry['user_modified_url'];
                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Using user_modified_url from database: ' . $replacement_url);
            } elseif (!empty($entry['suggested_url'])) {
                $replacement_url = $entry['suggested_url'];
                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Using suggested_url from database: ' . $replacement_url);
            }

            // If still no replacement URL and it's external, skip (only if no custom URL provided)
            if (empty($replacement_url)) {
                if ($entry['link_type'] === 'external') {
                    \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Skipping external link with no replacement: ' . $entry['broken_url']);
                    $skipped_count++;
                    $messages[] = sprintf(
                        __('⚠️ Skipped external link: %s (manual intervention required)', 'seo-autofix-pro'),
                        esc_url($entry['broken_url'])
                    );
                    continue;
                }

                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] No replacement URL available for: ' . $entry['broken_url']);
                $failed_count++;
                $messages[] = sprintf(
                    __('❌ No replacement URL for: %s', 'seo-autofix-pro'),
                    esc_url($entry['broken_url'])
                );
                continue;
            }

            // Apply fix to the content
            \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Attempting to replace link in content. Found on: ' . $entry['found_on_url'] . ', Broken: ' . $entry['broken_url'] . ', Replacement: ' . $replacement_url);

            $success = $this->replace_link_in_content(
                $entry['found_on_url'],
                $entry['broken_url'],
                $replacement_url
            );

            \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Replace link result: ' . ($success ? 'SUCCESS' : 'FAILED'));

            if ($success) {
                $fixed_count++;
                $mark_result = $this->db_manager->mark_as_fixed($entry_id);
                \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Mark as fixed result for ID ' . $entry_id . ': ' . ($mark_result ? 'SUCCESS' : 'FAILED'));

                // Also replace in site-wide elements (menus, widgets, theme templates) if enabled
                $this->replace_in_site_wide_elements($entry['broken_url'], $replacement_url);

                // Log activity for reporting
                global $wpdb;
                $table_activity = $wpdb->prefix . 'seoautofix_broken_links_activity';

                \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG] Attempting to log fix/replace activity for ID: ' . $entry_id);
                \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG] Scan ID: ' . $entry['scan_id']);
                \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG] Broken URL: ' . $entry['broken_url']);
                \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG] Replacement URL: ' . $replacement_url);
                \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG] Action type: ' . ($custom_url ? 'replaced' : 'fixed'));

                $insert_result = $wpdb->insert($table_activity, array(
                    'scan_id' => $entry['scan_id'],
                    'entry_id' => $entry_id,
                    'broken_url' => $entry['broken_url'],
                    'replacement_url' => $replacement_url,
                    'action_type' => $custom_url ? 'replaced' : 'fixed',
                    'page_url' => $entry['found_on_url'],
                    'page_title' => $entry['found_on_page_title']
                ), array('%s', '%d', '%s', '%s', '%s', '%s', '%s'));

                if ($insert_result === false) {
                    \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG ERROR] Failed to insert activity log! wpdb error: ' . $wpdb->last_error);
                    \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG ERROR] wpdb last_query: ' . $wpdb->last_query);
                } else {
                    \SEOAutoFix_Debug_Logger::log('[ACTIVITY LOG SUCCESS] Activity log entry created with ID: ' . $wpdb->insert_id);
                }

                $messages[] = sprintf(
                    __('✅ Fixed: %s → %s', 'seo-autofix-pro'),
                    esc_url($entry['broken_url']),
                    esc_url($replacement_url)
                );
            } else {
                $failed_count++;
                $messages[] = sprintf(
                    __('❌ Failed to fix: %s - Link not found in post content', 'seo-autofix-pro'),
                    esc_url($entry['broken_url'])
                );
            }
        }

        \SEOAutoFix_Debug_Logger::log('[APPLY_FIXES] Completed. Fixed: ' . $fixed_count . ', Failed: ' . $failed_count . ', Skipped: ' . $skipped_count);

        return array(
            'fixed_count' => $fixed_count,
            'failed_count' => $failed_count,
            'skipped_count' => $skipped_count,
            'messages' => $messages
        );
    }

    /**
     * Get post ID from URL with multiple fallback methods
     * Handles /index.php/ URLs and other WordPress URL formats
     * 
     * @param string $url The URL to get post ID from
     * @return int Post ID or 0 if not found
     */
    private function get_post_id_from_url($url)
    {
        \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Attempting to get post ID from URL: ' . $url);

        // Method 1: Standard WordPress url_to_postid()
        $post_id = url_to_postid($url);
        if ($post_id) {
            \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 1 (url_to_postid) succeeded: ' . $post_id);
            return $post_id;
        }

        // Method 2: Try removing /index.php/ if present
        if (strpos($url, '/index.php/') !== false) {
            $normalized_url = str_replace('/index.php/', '/', $url);
            \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 2: Trying without /index.php/: ' . $normalized_url);
            $post_id = url_to_postid($normalized_url);
            if ($post_id) {
                \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 2 succeeded: ' . $post_id);
                return $post_id;
            }
        }

        // Method 3: Try to extract page slug from URL
        $parsed = parse_url($url);
        if (isset($parsed['path'])) {
            // Remove trailing slash and leading slashes
            $path = trim($parsed['path'], '/');
            
            // Remove index.php if present
            $path = str_replace('index.php/', '', $path);
            
            // Get the last segment (page slug)
            $segments = explode('/', $path);
            $page_slug = end($segments);
            
            if (!empty($page_slug)) {
                \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 3: Extracted slug: ' . $page_slug);
                
                // Try to find page by slug
                $page = get_page_by_path($page_slug, OBJECT, array('post', 'page'));
                if ($page) {
                    \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 3 succeeded via get_page_by_path: ' . $page->ID);
                    return $page->ID;
                }
                
                // Try WP_Query as fallback
                \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 3b: Trying WP_Query with pagename');
                $query = new \WP_Query(array(
                    'pagename' => $page_slug,
                    'post_type' => array('post', 'page'),
                    'posts_per_page' => 1
                ));
                
                if ($query->have_posts()) {
                    $query->the_post();
                    $found_id = get_the_ID();
                    wp_reset_postdata();
                    \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 3b succeeded via WP_Query: ' . $found_id);
                    return $found_id;
                }
                wp_reset_postdata();
            }
        }

        // Method 4: Try to match against all pages/posts by URL
        \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 4: Querying all pages/posts to find URL match');
        global $wpdb;
        
        // Get all published posts and pages
        $posts = $wpdb->get_results(
            "SELECT ID FROM {$wpdb->posts} 
            WHERE post_status = 'publish' 
            AND post_type IN ('post', 'page')
            ORDER BY ID DESC
            LIMIT 500"
        );
        
        foreach ($posts as $post) {
            $post_url = get_permalink($post->ID);
            // Compare normalized URLs (without trailing slashes)
            if (untrailingslashit($post_url) === untrailingslashit($url)) {
                \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] Method 4 succeeded by permalink match: ' . $post->ID);
                return $post->ID;
            }
        }

        \SEOAutoFix_Debug_Logger::log('[GET_POST_ID] All methods failed - could not find post ID');
        return 0;
    }

    /**
     * Replace link in post/page content
     * 
     * @param string $page_url Page where link was found
     * @param string $broken_url Broken URL to replace
     * @param string $replacement_url New URL
     * @return bool Success
     */
    private function replace_link_in_content($page_url, $broken_url, $replacement_url)
    {
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Starting. Page URL: ' . $page_url . ', Broken: ' . $broken_url . ', Replacement: ' . $replacement_url);

        // Get post ID from URL with multiple fallback methods
        $post_id = $this->get_post_id_from_url($page_url);

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Post ID from URL: ' . $post_id);

        if (!$post_id) {
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Failed to get post ID from URL after all fallback attempts');
            return false;
        }

        // Check feature flag for universal replacement engine
        $use_universal = $this->use_universal_engine();
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Use universal engine: ' . ($use_universal ? 'YES' : 'NO (legacy mode)'));

        if ($use_universal) {
            // NEW: Universal replacement approach (builder-agnostic)
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Using universal replacement engine');
            
            $result = $this->universal_engine->replace_url_in_post($post_id, $broken_url, $replacement_url);
            
            if ($result['success']) {
                \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] ✅ Universal engine succeeded');
                \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Replacements made: ' . $result['stats']['replacements_made']);
                return true;
            }
            
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] ⚠️ Universal engine found no occurrences');
            return false;
        }

        // LEGACY: Original Elementor-specific approach (kept for backward compatibility)
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Using LEGACY replacement mode');

        // Check if this is an Elementor page
        $is_elementor = $this->is_elementor_page($post_id);
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Is Elementor page: ' . ($is_elementor ? 'YES' : 'NO'));

        if ($is_elementor) {
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Detected Elementor page - trying Elementor handler first');
            $elementor_result = $this->replace_link_in_elementor($post_id, $broken_url, $replacement_url);
            
            if ($elementor_result) {
                \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] ✅ Elementor replacement succeeded');
                return true;
            }
            
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] ⚠️ Elementor replacement failed - trying fallback to post_content');
            // Fall through to try post_content as fallback
        }

        // Regular WordPress page - continue with post_content replacement
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Regular WordPress page - using post_content replacement');

        // Get post content
        $post = get_post($post_id);

        if (!$post) {
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Failed to get post object for ID: ' . $post_id);
            return false;
        }

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Got post. Title: ' . $post->post_title . ', Content length: ' . strlen($post->post_content));

        $content = $post->post_content;
        
        // CRITICAL: Check if broken URL exists in content at all
        if (stripos($content, $broken_url) === false) {
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] ❌ Broken URL NOT FOUND in post_content at all!');
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] This means the link is likely in: theme template, header/footer, or widget');
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Content preview (first 500 chars): ' . substr($content, 0, 500));
            return false;
        }
        
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] ✅ Broken URL FOUND in post_content - proceeding with replacement');

        // Normalize URLs - remove trailing slashes for comparison
        $normalized_broken = untrailingslashit($broken_url);
        $normalized_replacement = untrailingslashit($replacement_url);

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Original broken URL: ' . $broken_url);
        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Normalized broken URL: ' . $normalized_broken);

        // Multiple patterns to catch different URL formats in HTML
        // This handles: trailing slashes, HTML entities, different quote styles, plain text
        $patterns = array();
        $replacements = array();

        // Pattern 1: Standard href with double quotes - exact match
        $patterns[] = '/href="' . preg_quote($broken_url, '/') . '"/i';
        $replacements[] = 'href="' . esc_url($replacement_url) . '"';

        // Pattern 2: Standard href with single quotes - exact match
        $patterns[] = "/href='" . preg_quote($broken_url, '/') . "'/i";
        $replacements[] = 'href="' . esc_url($replacement_url) . '"';

        // Pattern 3: Standard src with double quotes - exact match
        $patterns[] = '/src="' . preg_quote($broken_url, '/') . '"/i';
        $replacements[] = 'src="' . esc_url($replacement_url) . '"';

        // Pattern 4: Standard src with single quotes - exact match
        $patterns[] = "/src='" . preg_quote($broken_url, '/') . "'/i";
        $replacements[] = 'src="' . esc_url($replacement_url) . '"';

        // Pattern 5: href with optional trailing slash (normalized version)
        $patterns[] = '/href="' . preg_quote($normalized_broken, '/') . '\/?"/i';
        $replacements[] = 'href="' . esc_url($replacement_url) . '"';

        // Pattern 6: href with single quotes and optional trailing slash
        $patterns[] = "/href='" . preg_quote($normalized_broken, '/') . '\/?' . "'/i";
        $replacements[] = 'href="' . esc_url($replacement_url) . '"';

        // Pattern 7: src with optional trailing slash (normalized version)
        $patterns[] = '/src="' . preg_quote($normalized_broken, '/') . '\/?"/i';
        $replacements[] = 'src="' . esc_url($replacement_url) . '"';

        // Pattern 8: src with single quotes and optional trailing slash
        $patterns[] = "/src='" . preg_quote($normalized_broken, '/') . '\/?' . "'/i";
        $replacements[] = 'src="' . esc_url($replacement_url) . '"';

        // Pattern 9: HTML entity quotes (&quot;) - exact match
        $patterns[] = '/href=&quot;' . preg_quote($broken_url, '/') . '&quot;/i';
        $replacements[] = 'href=&quot;' . esc_url($replacement_url) . '&quot;';

        // Pattern 10: HTML entity quotes for src
        $patterns[] = '/src=&quot;' . preg_quote($broken_url, '/') . '&quot;/i';
        $replacements[] = 'src=&quot;' . esc_url($replacement_url) . '&quot;';

        // Pattern 11: HTML entity quotes with optional trailing slash
        $patterns[] = '/href=&quot;' . preg_quote($normalized_broken, '/') . '\/?&quot;/i';
        $replacements[] = 'href=&quot;' . esc_url($replacement_url) . '&quot;';

        // Pattern 12: Plain text URL (not in attributes) - be careful with this one
        // Only match if not preceded by quote or equals
        $patterns[] = '/(?<!["\'=>])' . preg_quote($broken_url, '/') . '(?!["\'])/i';
        $replacements[] = esc_url($replacement_url);

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Using ' . count($patterns) . ' patterns for flexible matching');

        $new_content = preg_replace($patterns, $replacements, $content);

        // Check if replacement was made
        if ($new_content === $content) {
            // No changes made with regex, try simple string replacement as fallback
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Regex patterns did not match, trying simple string replace');

            // Try exact string replacement
            $new_content = str_replace($broken_url, $replacement_url, $content);

            // If still no match, try without trailing slash
            if ($new_content === $content && $broken_url !== $normalized_broken) {
                \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Trying normalized URL without trailing slash');
                $new_content = str_replace($normalized_broken, $normalized_replacement, $content);
            }

            // Final check
            if ($new_content === $content) {
                \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] No changes made - link not found in content in any format');
                \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Content preview: ' . substr($content, 0, 500));
                return false;
            }
        }

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Content changed. Old length: ' . strlen($content) . ', New length: ' . strlen($new_content));

        // Update post
        $result = wp_update_post(array(
            'ID' => $post_id,
            'post_content' => $new_content
        ), true);

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] wp_update_post result: ' . print_r($result, true) . ', is_wp_error: ' . (is_wp_error($result) ? 'YES' : 'NO'));

        return !is_wp_error($result);
    }

    /**
     * Check if a link is template-generated and cannot be fixed programmatically
     * 
     * @param string $url The URL to check
     * @return bool True if template-generated
     */
    private function is_template_generated_link($url)
    {
        // Common patterns for template-generated links
        $template_patterns = array(
            '#respond',              // Comment reply links
            '#comment-',             // Comment anchors
            '/wp-admin/',           // Admin links
            '/wp-login.php',        // Login links
            '/wp-comments-post.php', // Comment form actions
            '/feed/',               // Feed links
            '?replytocom=',         // Reply to comment parameter
        );

        foreach ($template_patterns as $pattern) {
            if (strpos($url, $pattern) !== false) {
                \SEOAutoFix_Debug_Logger::log('[IS_TEMPLATE_GENERATED] URL contains pattern: ' . $pattern);
                return true;
            }
        }

        return false;
    }

    /**
     * Get statistics for scan results
     * 
     * @param string $scan_id Scan ID
     * @return array Statistics
     */
    public function get_scan_statistics($scan_id)
    {
        global $wpdb;

        $table_results = $wpdb->prefix . 'seoautofix_broken_links_scan_results';

        $stats = array(
            'total_broken' => 0,
            'internal_broken' => 0,
            'external_broken' => 0,
            'fixed' => 0,
            'pending' => 0
        );

        // Get total broken links
        $stats['total_broken'] = $wpdb->get_var(
            $wpdb->prepare(
                "SELECT COUNT(*) FROM {$table_results} 
                WHERE scan_id = %s AND is_deleted = 0",
                $scan_id
            )
        );

        // Get internal broken links
        $stats['internal_broken'] = $wpdb->get_var(
            $wpdb->prepare(
                "SELECT COUNT(*) FROM {$table_results} 
                WHERE scan_id = %s AND is_deleted = 0 AND link_type = 'internal'",
                $scan_id
            )
        );

        // Get external broken links
        $stats['external_broken'] = $wpdb->get_var(
            $wpdb->prepare(
                "SELECT COUNT(*) FROM {$table_results} 
                WHERE scan_id = %s AND is_deleted = 0 AND link_type = 'external'",
                $scan_id
            )
        );

        // Get fixed links
        $stats['fixed'] = $wpdb->get_var(
            $wpdb->prepare(
                "SELECT COUNT(*) FROM {$table_results} 
                WHERE scan_id = %s AND is_fixed = 1",
                $scan_id
            )
        );

        // Get pending links
        $stats['pending'] = $stats['total_broken'] - $stats['fixed'];

        return $stats;
    }

    /**
     * Check if a post is built with Elementor
     * 
     * @param int $post_id Post ID  
     * @return bool True if Elementor page
     */
    public function is_elementor_page($post_id)
    {
        return get_post_meta($post_id, '_elementor_edit_mode', true) === 'builder';
    }

    /**
     * Get Elementor data for a post
     * 
     * @param int $post_id Post ID
     * @return array|false Elementor data array or false
     */
    public function get_elementor_data($post_id)
    {
        $data = get_post_meta($post_id, '_elementor_data', true);

        if (empty($data)) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] No _elementor_data found for post ID: ' . $post_id);
            return false;
        }

        $decoded = json_decode($data, true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] JSON decode error: ' . json_last_error_msg());
            return false;
        }

        return $decoded;
    }

    /**
     * Replace link in Elementor page
     * 
     * @param int $post_id Post ID
     * @param string $broken_url URL to replace
     * @param string $replacement_url New URL
     * @return bool True on success
     */
    private function replace_link_in_elementor($post_id, $broken_url, $replacement_url)
    {
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Starting replacement for post ID: ' . $post_id);
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Broken URL: ' . $broken_url);
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Replacement URL: ' . $replacement_url);

        // Get Elementor data
        $data = $this->get_elementor_data($post_id);

        if ($data === false) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Failed to get Elementor data');
            return false;
        }

        // Track if any replacement was made
        $replaced = false;

        // Recursively replace URLs in the data structure
        $modified_data = $this->replace_url_in_elementor_data_recursive($data, $broken_url, $replacement_url, $replaced);

        if (!$replaced) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] No replacements made - URL not found in Elementor data');
            return false;
        }

        // Save the modified data
        return $this->save_elementor_data($post_id, $modified_data);
    }

    /**
     * Recursively replace URLs in Elementor data structure
     * 
     * @param mixed $data Current data element
     * @param string $broken_url URL to replace
     * @param string $replacement_url New URL
     * @param bool &$replaced Reference to track if replacement occurred
     * @return mixed Modified data
     */
    private function replace_url_in_elementor_data_recursive($data, $broken_url, $replacement_url, &$replaced, $depth = 0)
    {
        static $url_checks = 0;
        
        // Log every 100 checks to avoid overwhelming logs
        if ($depth === 0) {
            $url_checks = 0;
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR RECURSIVE] Starting search for broken URL: ' . $broken_url);
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR RECURSIVE] Replacement URL: ' . $replacement_url);
        }

        // Handle arrays
        if (is_array($data)) {
            foreach ($data as $key => $value) {
                // Check specific Elementor fields that commonly contain URLs
                if ($key === 'url' && is_string($value)) {
                    $url_checks++;
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR RECURSIVE] Checking URL field at depth ' . $depth . ': ' . $value);
                    
                    // Direct URL field - try multiple matching strategies
                    if ($this->urls_match($value, $broken_url)) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] ✅ Found URL in field: ' . $key . ' = ' . $value);
                        $data[$key] = $replacement_url;
                        $replaced = true;
                    } elseif (stripos($value, $broken_url) !== false) {
                        // URL might be part of a longer string
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] ✅ Found URL as substring in field: ' . $key);
                        $data[$key] = str_replace($broken_url, $replacement_url, $value);
                        $replaced = true;
                    }
                } elseif ($key === 'link' && is_array($value) && isset($value['url'])) {
                    $url_checks++;
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR RECURSIVE] Checking link.url at depth ' . $depth . ': ' . $value['url']);
                    
                    // Link object with URL property
                    if ($this->urls_match($value['url'], $broken_url)) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] ✅ Found URL in link.url: ' . $value['url']);
                        $data[$key]['url'] = $replacement_url;
                        $replaced = true;
                    } elseif (stripos($value['url'], $broken_url) !== false) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] ✅ Found URL as substring in link.url');
                        $data[$key]['url'] = str_replace($broken_url, $replacement_url, $value['url']);
                        $replaced = true;
                    }
                } elseif (in_array($key, ['text', 'editor', 'html', 'code', 'title', 'content']) && is_string($value)) {
                    // Text/HTML fields that might contain links
                    if (stripos($value, $broken_url) !== false) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] ✅ Found URL in text field "' . $key . '" at depth ' . $depth);
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Text preview: ' . substr($value, 0, 200));
                        $data[$key] = str_replace($broken_url, $replacement_url, $value);
                        $replaced = true;
                    }
                } else {
                    // Recursively process nested structures
                    $data[$key] = $this->replace_url_in_elementor_data_recursive($value, $broken_url, $replacement_url, $replaced, $depth + 1);
                }
            }
        }
        
        // Log summary at the end
        if ($depth === 0) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR RECURSIVE] Search complete. Checked ' . $url_checks . ' URL fields. Replaced: ' . ($replaced ? 'YES' : 'NO'));
        }

        return $data;
    }

    /**
     * Check if two URLs match (handles trailing slashes AND domain differences for migrations)
     * 
     * @param string $url1 First URL
     * @param string $url2 Second URL
     * @return bool True if URLs match
     */
    private function urls_match($url1, $url2)
    {
        // Method 1: Exact match after normalizing trailing slashes
        $normalized1 = untrailingslashit($url1);
        $normalized2 = untrailingslashit($url2);
        
        if ($normalized1 === $normalized2) {
            \SEOAutoFix_Debug_Logger::log('[URL_MATCH] ✅ Exact match: ' . $url1);
            return true;
        }
        
        // Method 2: Path-only match (for site migrations where domain changed)
        // Extract paths from both URLs
        $parsed1 = parse_url($url1);
        $parsed2 = parse_url($url2);
        
        if (isset($parsed1['path']) && isset($parsed2['path'])) {
            $path1 = untrailingslashit($parsed1['path']);
            $path2 = untrailingslashit($parsed2['path']);
            
            // Also compare query strings if both have them
            $query1 = isset($parsed1['query']) ? $parsed1['query'] : '';
            $query2 = isset($parsed2['query']) ? $parsed2['query'] : '';
            
            if ($path1 === $path2 && $query1 === $query2) {
                \SEOAutoFix_Debug_Logger::log('[URL_MATCH] ✅ Path match (domain migration): ' . $url1 . ' ≈ ' . $url2);
                \SEOAutoFix_Debug_Logger::log('[URL_MATCH] Path1: ' . $path1 . ' | Path2: ' . $path2);
                return true;
            }
        }
        
        return false;
    }

    /**
     * Save Elementor data and clear cache
     * 
     * @param int $post_id Post ID
     * @param array $data Modified Elementor data
     * @return bool True on success
     */
    public function save_elementor_data($post_id, $data)
    {
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Saving modified data for post ID: ' . $post_id);

        // Encode data
        $json = wp_json_encode($data);

        if ($json === false) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Failed to encode data to JSON');
            return false;
        }

        // Update post meta
        $result = update_post_meta($post_id, '_elementor_data', wp_slash($json));

        if ($result === false) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Failed to update post meta');
            return false;
        }

        // Clear Elementor cache
        if (class_exists('\\Elementor\\Plugin')) {
            try {
                \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Clearing Elementor cache');
                \Elementor\Plugin::$instance->files_manager->clear_cache();
            } catch (\Exception $e) {
                \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Cache clear error: ' . $e->getMessage());
                // Don't fail if cache clear fails
            }
        }

        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR] Successfully saved and cleared cache');
        return true;
    }

    /**
     * Remove link from Elementor page (Option A: keep content, remove link)
     * 
     * @param int $post_id Post ID
     * @param string $broken_url URL to remove
     * @return bool True on success
     */
    public function remove_link_from_elementor($post_id, $broken_url)
    {
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Starting link removal for post ID: ' . $post_id);
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Broken URL: ' . $broken_url);

        // Get Elementor data
        $data = $this->get_elementor_data($post_id);

        if ($data === false) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Failed to get Elementor data');
            return false;
        }

        // Track if any removal was made
        $removed = false;

        // Recursively remove URLs in the data structure
        $modified_data = $this->remove_url_from_elementor_data_recursive($data, $broken_url, $removed);

        if ($removed) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ Found and removed from Elementor data');
            // Save the modified data
            return $this->save_elementor_data($post_id, $modified_data);
        }

        // ========== FALLBACK: Check post_content instead ==========
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Not found in Elementor data, checking post_content as fallback');
        
        $post = get_post($post_id);
        if (!$post) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Failed to get post object');
            return false;
        }

        $content = $post->post_content;
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] post_content length: ' . strlen($content) . ' chars');
        
        // Check if URL exists in post_content
        if (stripos($content, $broken_url) === false) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ❌ URL not found in post_content either');
            return false;
        }

        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ URL FOUND in post_content! Removing...');
        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Content preview: ' . substr($content, 0, 500));

        // Remove the link tag but keep the anchor text
        $patterns = array(
            '/<a\s+[^>]*href=["\']' . preg_quote($broken_url, '/') . '["\'][^>]*>(.*?)<\/a>/is',
            '/<a\s+[^>]*href=["\']' . preg_quote(untrailingslashit($broken_url), '/') . '\/?' . '["\'][^>]*>(.*?)<\/a>/is',
        );

        $new_content = $content;
        $total_replacements = 0;

        foreach ($patterns as $index => $pattern) {
            $count = 0;
            $new_content = preg_replace($pattern, '$1', $new_content, -1, $count);
            if ($count > 0) {
                \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] post_content pattern ' . ($index + 1) . ' matched ' . $count . ' times');
                $total_replacements += $count;
            }
        }

        // Also handle img tags
        $img_pattern = '/<img\s+[^>]*src=["\']' . preg_quote($broken_url, '/') . '["\'][^>]*\/?>/i';
        $img_count = 0;
        $new_content = preg_replace($img_pattern, '', $new_content, -1, $img_count);
        if ($img_count > 0) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] post_content img pattern matched ' . $img_count . ' times');
            $total_replacements += $img_count;
        }

        if ($new_content === $content) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ❌ No changes made to post_content');
            return false;
        }

        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ Modified post_content, total replacements: ' . $total_replacements);

        // Update post_content
        $result = wp_update_post(array(
            'ID' => $post_id,
            'post_content' => $new_content
        ), true);

        if (is_wp_error($result)) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ❌ wp_update_post failed: ' . $result->get_error_message());
            return false;
        }

        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ Successfully updated post_content!');
        return true;
    }

    /**
     * Recursively remove URLs from Elementor data structure
     * Option A: Keep content (text, buttons, images), just remove/clear the broken URL
     * 
     * @param mixed $data Current data element
     * @param string $broken_url URL to remove
     * @param bool &$removed Reference to track if removal occurred
     * @return mixed Modified data
     */
    private function remove_url_from_elementor_data_recursive($data, $broken_url, &$removed, $depth = 0)
    {
        // Add depth tracking and initial logging
        if ($depth === 0) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ==================== START ====================');
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Searching for URL: ' . $broken_url);
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Data type: ' . gettype($data));
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Is array: ' . (is_array($data) ? 'YES' : 'NO'));
            if (is_array($data)) {
                \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Array size: ' . count($data));
                \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Array keys: ' . implode(', ', array_keys($data)));
            }
        }

        // Handle arrays
        if (is_array($data)) {
            foreach ($data as $key => $value) {
                // Log every field we're checking
                if ($depth < 3) { // Only log top 3 levels to avoid spam
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Depth ' . $depth . ' - Checking key: "' . $key . '" (type: ' . gettype($value) . ')');
                }

                // Check specific Elementor fields that commonly contain URLs
                if ($key === 'url' && is_string($value)) {
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ✓ Found URL field at depth ' . $depth .  ': ' . $value);
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Comparing with broken URL: ' . $broken_url);
                    
                    // Direct URL field - clear it if it matches
                    if ($this->urls_match($value, $broken_url)) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ MATCH! Clearing URL in field: ' . $key . ' = ' . $value);
                        $data[$key] = ''; // Clear the URL but keep the field
                        $removed = true;
                    } else {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ❌ No match. URL field contains: ' . $value);
                    }
                } elseif ($key === 'link' && is_array($value) && isset($value['url'])) {
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ✓ Found link object at depth ' . $depth . ' with URL: ' . $value['url']);
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Comparing with broken URL: ' . $broken_url);
                    
                    // Link object with URL property - clear the url but keep the link structure
                    if ($this->urls_match($value['url'], $broken_url)) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ MATCH! Clearing URL in link.url: ' . $value['url']);
                        $data[$key]['url'] = ''; // Clear URL
                        $data[$key]['is_external'] = ''; // Clear external flag
                        $data[$key]['nofollow'] = ''; // Clear nofollow
                        $removed = true;
                    } else {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ❌ No match. link.url contains: ' . $value['url']);
                    }
                } elseif (in_array($key, ['text', 'editor', 'html', 'code', 'title', 'content']) && is_string($value)) {
                    // Text/HTML fields that might contain links in HTML format
                    $value_preview = substr($value, 0, 200);
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ✓ Found text field "' . $key . '" at depth ' . $depth);
                    \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Content preview: ' . $value_preview);
                    
                    // ✅ SPECIAL CHECK: If this looks like our anchor text, show FULL content
                    if (stripos($value, 'Stories are the threads') !== false) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ⚠️ ANCHOR TEXT DETECTED! Showing FULL content:');
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] FULL CONTENT: ' . $value);
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] Content length: ' . strlen($value) . ' chars');
                    }
                    
                    // Remove <a> tags but keep anchor text
                    if (stripos($value, $broken_url) !== false) {
                        \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ FOUND URL in text field: ' . $key);
                        
                        // Pattern to match <a href="broken_url">text</a> and replace with just text
                        $patterns = array(
                            '/<a\s+[^>]*href=["\']' . preg_quote($broken_url, '/') . '["\'][^>]*>(.*?)<\/a>/is',
                            '/<a\s+[^>]*href=["\']' . preg_quote(untrailingslashit($broken_url), '/') . '\/?' . '["\'][^>]*>(.*?)<\/a>/is',
                        );
                        
                        $new_value = $value;
                        $pattern_matched = false;
                        
                        foreach ($patterns as $index => $pattern) {
                            $count = 0;
                            $new_value = preg_replace($pattern, '$1', $new_value, -1, $count);
                            if ($count > 0) {
                                \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Pattern ' . ($index + 1) . ' matched ' . $count . ' times');
                                $pattern_matched = true;
                            }
                        }
                        
                        // Also handle plain URL replacement if it's just text
                        if (str_replace($broken_url, '', $new_value) !== $new_value) {
                            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] Also found plain URL in text, removing');
                            $new_value = str_replace($broken_url, '', $new_value);
                            $pattern_matched = true;
                        }
                        
                        if ($new_value !== $value) {
                            $data[$key] = $new_value;
                            $removed = true;
                            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ✅ Removed link from text field, kept anchor text');
                        } else {
                            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE] ⚠️ URL found but no changes made (regex didn\'t match)');
                        }
                    } else {
                        if ($depth < 3) {
                            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ❌ URL not found in text field "' . $key . '"');
                        }
                    }
                } else {
                    // Recursively process nested structures
                    $data[$key] = $this->remove_url_from_elementor_data_recursive($value, $broken_url, $removed, $depth + 1);
                }
            }
        }
        
        if ($depth === 0) {
            \SEOAutoFix_Debug_Logger::log('[ELEMENTOR DELETE RECURSIVE] ==================== END ====================');
        }

        return $data;
    }

    /**
     * Check if universal replacement engine should be used
     * 
     * @return bool True to use universal engine, false for legacy mode
     */
    private function use_universal_engine()
    {
        // Allow filtering via code
        $use_universal = apply_filters('seoautofix_use_universal_replacement', true);
        
        // Check settings option
        $settings = get_option('seoautofix_settings', []);
        if (isset($settings['universal_replacement'])) {
            $use_universal = (bool) $settings['universal_replacement'];
        }
        
        return $use_universal;
    }

    /**
     * Check if header/footer replacement is enabled
     * 
     * @return bool True if enabled
     */
    private function is_header_footer_replacement_enabled()
    {
        // Allow filtering via code
        $enabled = apply_filters('seoautofix_replace_in_header_footer', false);
        
        // Check settings option
        $settings = get_option('seoautofix_settings', []);
        if (isset($settings['replace_in_header_footer'])) {
            $enabled = (bool) $settings['replace_in_header_footer'];
        }
        
        return $enabled;
    }

    /**
     * Replace URL in site-wide elements (menus, widgets, templates)
     * 
     * @param string $old_url URL to replace
     * @param string $new_url Replacement URL
     * @return bool Success
     */
    private function replace_in_site_wide_elements($old_url, $new_url)
    {
        if (!$this->is_header_footer_replacement_enabled()) {
            \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Header/footer replacement is disabled in settings');
            return false;
        }

        \SEOAutoFix_Debug_Logger::log('[REPLACE_LINK] Replacing in site-wide elements (menus, widgets, templates)');
        
        $result = $this->header_footer_replacer->replace_in_site_wide_elements($old_url, $new_url);
        
        return $result['success'];
    }
}
